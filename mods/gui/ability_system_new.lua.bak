-- Advanced Ability System with Visual Graph! âš¡âœ¨
-- Stat-based abilities with min/max unlocks + Boolean toggles

-- Ability definitions with graph positions
local abilities = {
    -- Movement stat modifiers (unlock ranges)
    {
        id = "walk_speed",
        name = "Walk Speed",
        type = "stat",
        icon = "ðŸš¶",
        description = "Increases walk speed range",
        category = "movement",
        cost = 1,
        max_level = 5,
        requires = nil,
        graph_x = 1,
        graph_y = 1,
        stat_key = "speed",
        base_min = 1.0,
        base_max = 1.0,
        unlock_per_level = 0.2,  -- Each level adds 0.2 to max
    },
    {
        id = "run_speed",
        name = "Run Speed Boost",
        type = "stat",
        icon = "ðŸƒ",
        description = "Further increases speed maximum",
        category = "movement",
        cost = 2,
        max_level = 3,
        requires = "walk_speed",
        graph_x = 2,
        graph_y = 1,
        stat_key = "speed",
        unlock_per_level = 0.3,
    },
    {
        id = "jump_height",
        name = "Jump Height",
        type = "stat",
        icon = "â¬†ï¸",
        description = "Increases jump height range",
        category = "movement",
        cost = 1,
        max_level = 5,
        requires = nil,
        graph_x = 1,
        graph_y = 2,
        stat_key = "jump",
        base_min = 1.0,
        base_max = 1.0,
        unlock_per_level = 0.25,
    },
    {
        id = "super_jump",
        name = "Super Jump",
        type = "stat",
        icon = "ðŸ¦˜",
        description = "Massive jump boost",
        category = "movement",
        cost = 3,
        max_level = 2,
        requires = "jump_height",
        graph_x = 2,
        graph_y = 2,
        stat_key = "jump",
        unlock_per_level = 0.5,
    },
    
    -- Flight abilities
    {
        id = "fly_enable",
        name = "Flight",
        type = "toggle",
        icon = "ðŸ•Šï¸",
        description = "Enable flying (creative-style, never clamped)",
        category = "flight",
        cost = 5,
        requires = "super_jump",
        graph_x = 3,
        graph_y = 2,
        priv = "fly",  -- Grant fly privilege
    },
    {
        id = "fly_speed",
        name = "Fly Speed",
        type = "stat",
        icon = "âœˆï¸",
        description = "Increases flight speed (unclamped!)",
        category = "flight",
        cost = 2,
        max_level = 5,
        requires = "fly_enable",
        graph_x = 4,
        graph_y = 2,
        stat_key = "speed",
        unlock_per_level = 0.4,
        unclamped = true,  -- Can go beyond normal limits!
    },
    
    -- Utility stats
    {
        id = "crouch_speed",
        name = "Sneak Speed",
        type = "stat",
        icon = "ðŸ¢",
        description = "Move faster while crouching",
        category = "utility",
        cost = 1,
        max_level = 3,
        requires = nil,
        graph_x = 1,
        graph_y = 3,
        stat_key = "sneak_speed",
        base_min = 0.3,
        base_max = 0.3,
        unlock_per_level = 0.15,
    },
    {
        id = "swim_speed",
        name = "Swim Speed",
        type = "stat",
        icon = "ðŸŠ",
        description = "Swim faster underwater",
        category = "utility",
        cost = 1,
        max_level = 3,
        requires = nil,
        graph_x = 1,
        graph_y = 4,
        stat_key = "swim_speed",
        base_min = 1.0,
        base_max = 1.0,
        unlock_per_level = 0.2,
    },
    
    -- Boolean toggle abilities
    {
        id = "noclip",
        name = "No-Clip",
        type = "toggle",
        icon = "ðŸ‘»",
        description = "Phase through walls",
        category = "utility",
        cost = 10,
        requires = "fly_enable",
        graph_x = 5,
        graph_y = 2,
        priv = "noclip",
    },
    {
        id = "fast_dig",
        name = "Fast Digging",
        type = "toggle",
        icon = "âš¡",
        description = "Mine blocks instantly",
        category = "utility",
        cost = 8,
        requires = nil,
        graph_x = 2,
        graph_y = 4,
        priv = "fast",
    },
    {
        id = "teleport",
        name = "Teleportation",
        type = "toggle",
        icon = "ðŸŒ€",
        description = "Teleport to waypoints",
        category = "utility",
        cost = 7,
        requires = nil,
        graph_x = 3,
        graph_y = 4,
        priv = "teleport",
    },
}

-- Build lookup tables
local ability_by_id = {}
for _, ability in ipairs(abilities) do
    ability_by_id[ability.id] = ability
end

-- Get player ability data
local function get_ability_data(player)
    local meta = player:get_meta()
    local data_str = meta:get_string("abilities_v2")
    if data_str == "" then data_str = "{}" end
    local data = minetest.deserialize(data_str) or {}
    
    if not data.unlocked then
        data.unlocked = {}  -- {ability_id = level}
        data.stat_points = 0
        data.stat_values = {}  -- {stat_key = value}
        data.toggles = {}  -- {ability_id = true/false}
        data.scroll_x = 0  -- Horizontal scroll position (0-1000)
        data.scroll_y = 0  -- Vertical scroll position (0-1000)
    end
    data.scroll_x = data.scroll_x or 0
    data.scroll_y = data.scroll_y or 0
    
    return data
end

-- Save ability data
local function save_ability_data(player, data)
    local meta = player:get_meta()
    meta:set_string("abilities_v2", minetest.serialize(data))
end

-- Calculate stat range based on unlocked abilities
local function get_stat_range(player, stat_key)
    local data = get_ability_data(player)
    local min_val = 1.0
    local max_val = 1.0
    local unclamped = false
    
    for _, ability in ipairs(abilities) do
        if ability.type == "stat" and ability.stat_key == stat_key then
            local level = data.unlocked[ability.id] or 0
            if level > 0 then
                if ability.base_min then
                    min_val = math.min(min_val, ability.base_min)
                end
                if ability.base_max then
                    max_val = math.max(max_val, ability.base_max + (ability.unlock_per_level * level))
                end
                if ability.unclamped then
                    unclamped = true
                end
            end
        end
    end
    
    return min_val, max_val, unclamped
end

-- Apply stat values to player
local function apply_stats(player)
    local data = get_ability_data(player)
    
    -- Apply speed
    local speed = data.stat_values.speed or 1.0
    local jump = data.stat_values.jump or 1.0
    
    player:set_physics_override({
        speed = speed,
        jump = jump,
    })
end

-- Apply toggle abilities
local function apply_toggles(player)
    local data = get_ability_data(player)
    local privs = minetest.get_player_privs(player:get_player_name())
    
    for _, ability in ipairs(abilities) do
        if ability.type == "toggle" and ability.priv then
            local level = data.unlocked[ability.id] or 0
            if level > 0 then
                -- Ability unlocked, check toggle state
                if data.toggles[ability.id] then
                    privs[ability.priv] = true
                else
                    privs[ability.priv] = nil
                end
            end
        end
    end
    
    minetest.set_player_privs(player:get_player_name(), privs)
end

-- Generate ability graph formspec
function get_ability_formspec_new(player)
    local data = get_ability_data(player)
    local exp = tonumber(player:get_meta():get_string("experience")) or 0
    local level = math.floor(exp / 100) + 1
    
    -- Get player model info
    local player_textures = player_api.get_textures(player) or {"character.png"}
    
    local formspec = {
        "formspec_version[4]",
        "size[14,11]",
        "bgcolor[#0a0a0aff;true]",
        
        -- 3D Player Model Preview (square, static)
        "box[0.2,0.3;1.5,1.5;#1a1a1aff]",
        "model[0.3,0.4;1.3,1.3;player_preview;character.b3d;" .. table.concat(player_textures, ",") .. ";0,170;false;false;0,0]",
        
        -- Header
        "box[0.2,2;13.6,0.6;#2a2a2aff]",
        "label[0.5,2.3;âš¡ Abilities - Level " .. level .. "]",
        "label[10,2.3;Stat Points: " .. data.stat_points .. "]",
    }
    
    -- LEFT SIDE: Stat Sliders & Toggle List
    table.insert(formspec, "box[0.2,2.8;4.5,7.9;#1a1a1aff]")
    table.insert(formspec, "label[0.5,3.1;ðŸ“Š Stats & Abilities]")
    
    local y = 3.5
    
    -- Stat sliders for each stat type
    local stat_types = {
        {key = "speed", label = "Movement Speed", icon = "ðŸƒ"},
        {key = "jump", label = "Jump Height", icon = "â¬†ï¸"},
        {key = "sneak_speed", label = "Crouch Speed", icon = "ðŸ¢"},
        {key = "swim_speed", label = "Swim Speed", icon = "ðŸŠ"},
    }
    
    for _, stat in ipairs(stat_types) do
        local min_val, max_val, unclamped = get_stat_range(player, stat.key)
        local current = data.stat_values[stat.key] or 1.0
        
        -- Clamp current value to range (unless unclamped)
        if not unclamped then
            current = math.max(min_val, math.min(max_val, current))
        end
        
        table.insert(formspec, string.format("label[0.5,%f;%s %s]", y, stat.icon, stat.label))
        table.insert(formspec, string.format("field[0.5,%f;1.8,0.5;stat_%s;;%.2f]", y + 0.3, stat.key, current))
        table.insert(formspec, string.format("field_close_on_enter[stat_%s;false]", stat.key))
        table.insert(formspec, string.format("button[2.4,%f;1,0.5;set_%s;Set]", y + 0.3, stat.key))
        
        if unclamped then
            table.insert(formspec, string.format("label[3.5,%f;âˆž]", y + 0.5))
        else
            table.insert(formspec, string.format("label[3.5,%f;%.1f-%.1f]", y + 0.5, min_val, max_val))
        end
        
        y = y + 1
    end
    
    -- Toggle abilities list
    y = y + 0.3
    table.insert(formspec, string.format("label[0.5,%f;ðŸ”˜ Toggle Abilities]", y))
    y = y + 0.4
    
    for _, ability in ipairs(abilities) do
        if ability.type == "toggle" then
            local level = data.unlocked[ability.id] or 0
            if level > 0 then
                local enabled = data.toggles[ability.id] or false
                local checkbox = enabled and "â˜‘" or "â˜"
                table.insert(formspec, string.format("button[0.5,%f;4,0.5;toggle_%s;%s %s %s]", 
                    y, ability.id, checkbox, ability.icon, ability.name))
                y = y + 0.6
            end
        end
    end
    
    -- RIGHT SIDE: Ability Graph
    table.insert(formspec, "box[4.9,2.8;8.9,7.9;#0a0a0aff]")
    table.insert(formspec, "label[5.2,3.1;ðŸ—ºï¸ Ability Tree (Use scrollbars to pan)]")
    
    -- Graph rendering area
    local graph_x = 5.1
    local graph_y = 3.5
    local graph_w = 8.2
    local graph_h = 7.0
    local node_size = 0.8
    local grid_spacing_x = 2.0
    local grid_spacing_y = 1.8
    
    -- Calculate total graph size
    local max_x = 0
    local max_y = 0
    for _, ability in ipairs(abilities) do
        max_x = math.max(max_x, ability.graph_x)
        max_y = math.max(max_y, ability.graph_y)
    end
    local total_width = (max_x + 1) * grid_spacing_x + node_size
    local total_height = (max_y + 1) * grid_spacing_y + node_size
    
    -- Get current scroll offsets (0-1000 range from scrollbar)
    local scroll_x = tonumber(data.scroll_x) or 0
    local scroll_y = tonumber(data.scroll_y) or 0
    
    -- Convert to pixel offsets
    local max_offset_x = math.max(0, total_width - graph_w)
    local max_offset_y = math.max(0, total_height - graph_h)
    local offset_x = -(scroll_x / 1000) * max_offset_x
    local offset_y = -(scroll_y / 1000) * max_offset_y
    
    -- Clip box for graph area
    table.insert(formspec, string.format("box[%f,%f;%f,%f;#0a0a2aff]", graph_x, graph_y, graph_w, graph_h))
    
    -- Draw edges first (so nodes are on top)
    for _, ability in ipairs(abilities) do
        if ability.requires then
            local parent = ability_by_id[ability.requires]
            if parent then
                local unlocked = (data.unlocked[ability.id] or 0) > 0
                local parent_unlocked = (data.unlocked[parent.id] or 0) > 0
                
                local x1 = graph_x + offset_x + parent.graph_x * grid_spacing_x + node_size / 2
                local y1 = graph_y + offset_y + parent.graph_y * grid_spacing_y + node_size / 2
                local x2 = graph_x + offset_x + ability.graph_x * grid_spacing_x + node_size / 2
                local y2 = graph_y + offset_y + ability.graph_y * grid_spacing_y + node_size / 2
                
                -- Only draw if visible in viewport
                if x1 >= graph_x - 0.5 and x1 <= graph_x + graph_w + 0.5 and
                   y1 >= graph_y - 0.5 and y1 <= graph_y + graph_h + 0.5 then
                    -- Draw line as series of boxes
                    local steps = 20
                    for i = 0, steps do
                        local t = i / steps
                        local x = x1 + (x2 - x1) * t
                        local y = y1 + (y2 - y1) * t
                        
                        local color = (unlocked and parent_unlocked) and "#4a9a4aff" or "#3a3a3aff"
                        table.insert(formspec, string.format("box[%f,%f;0.05,0.05;%s]", x, y, color))
                    end
                end
            end
        end
    end
    
    -- Draw nodes
    for _, ability in ipairs(abilities) do
        local x = graph_x + offset_x + ability.graph_x * grid_spacing_x
        local y = graph_y + offset_y + ability.graph_y * grid_spacing_y
        
        -- Only draw if visible in viewport
        if x + node_size >= graph_x and x <= graph_x + graph_w and
           y + node_size >= graph_y and y <= graph_y + graph_h then
            
            local level = data.unlocked[ability.id] or 0
            local unlocked = level > 0
            
            -- Check if can unlock
            local can_unlock = true
            if ability.requires then
                local req_level = data.unlocked[ability.requires] or 0
                can_unlock = req_level > 0
            end
            can_unlock = can_unlock and data.stat_points >= (ability.cost or 1)
            
            -- Node background
            local bg_color
            if unlocked then
                bg_color = "#2a5a2aff"  -- Green
            elseif can_unlock then
                bg_color = "#5a5a2aff"  -- Yellow
            else
                bg_color = "#2a2a2aff"  -- Gray
            end
            
            table.insert(formspec, string.format("box[%f,%f;%f,%f;%s]", x, y, node_size, node_size, bg_color))
            
            -- Node button with icon
            table.insert(formspec, string.format("button[%f,%f;%f,%f;node_%s;%s]", 
                x, y, node_size, node_size, ability.id, ability.icon))
            
            -- Level indicator
            if unlocked then
                if ability.max_level and ability.max_level > 1 then
                    table.insert(formspec, string.format("label[%f,%f;%d/%d]", 
                        x + 0.05, y + node_size - 0.2, level, ability.max_level))
                else
                    table.insert(formspec, string.format("label[%f,%f;âœ“]", 
                        x + 0.3, y + node_size - 0.2))
                end
            end
        end
    end
    
    -- Scrollbars for panning (0-1000 range)
    if max_offset_x > 0 then
        table.insert(formspec, string.format("scrollbar[13.5,%f;0.3,%f;horizontal;graph_scroll_x;%d]", 
            graph_y + graph_h + 0.2, graph_w, scroll_x))
    end
    if max_offset_y > 0 then
        table.insert(formspec, string.format("scrollbar[%f,%f;0.3,%f;vertical;graph_scroll_y;%d]", 
            graph_x + graph_w + 0.2, graph_y, graph_h, scroll_y))
    end
    
    -- Tooltip area (click nodes to see info here)
    table.insert(formspec, "box[0.2,10.5;13.6,0.3;#2a2a2aff]")
    local tooltip_text = data.tooltip or "Click nodes for info"
    table.insert(formspec, string.format("label[0.5,10.7;%s]", minetest.formspec_escape(tooltip_text)))
    
    return table.concat(formspec, "")
end

-- Handle formspec input
minetest.register_on_player_receive_fields(function(player, formname, fields)
    -- Handle both standalone and unified inventory
    if formname ~= "ability_tree_new" and formname ~= "" and formname ~= "unified_inventory" then
        return
    end
    
    -- Only process if we're on abilities tab in unified inventory
    if (formname == "" or formname == "unified_inventory") then
        local current_tab = player:get_meta():get_string("current_tab")
        if current_tab ~= "abilities" then
            return
        end
    end
    
    if fields.quit then
        return
    end
    
    local data = get_ability_data(player)
    local name = player:get_player_name()
    local changed = false
    
    -- Handle stat value changes
    for _, stat in ipairs({{"speed"}, {"jump"}, {"sneak_speed"}, {"swim_speed"}}) do
        local key = stat[1]
        if fields["set_" .. key] and fields["stat_" .. key] then
            local value = tonumber(fields["stat_" .. key])
            if value then
                local min_val, max_val, unclamped = get_stat_range(player, key)
                
                -- Clamp unless unclamped
                if not unclamped then
                    value = math.max(min_val, math.min(max_val, value))
                end
                
                data.stat_values[key] = value
                changed = true
                apply_stats(player)
            end
        end
    end
    
    -- Handle toggle abilities
    for _, ability in ipairs(abilities) do
        if ability.type == "toggle" and fields["toggle_" .. ability.id] then
            data.toggles[ability.id] = not (data.toggles[ability.id] or false)
            changed = true
            apply_toggles(player)
        end
    end
    
    -- Handle node clicks (unlock/upgrade or show tooltip)
    for _, ability in ipairs(abilities) do
        if fields["node_" .. ability.id] then
            local current_level = data.unlocked[ability.id] or 0
            local max_level = ability.max_level or 1
            
            -- Build tooltip text
            local tooltip = string.format("%s %s | Cost: %d SP | Level: %d/%d", 
                ability.icon, ability.name, ability.cost or 1, current_level, max_level or 1)
            if ability.requires then
                tooltip = tooltip .. " | Requires: " .. ability_by_id[ability.requires].name
            end
            tooltip = tooltip .. " | " .. ability.description
            data.tooltip = tooltip
            changed = true
            
            -- Try to unlock if shift-clicked or right-clicked
            if current_level < max_level then
                -- Check requirements
                local can_unlock = true
                if ability.requires then
                    local req_level = data.unlocked[ability.requires] or 0
                    if req_level == 0 then
                        can_unlock = false
                        minetest.chat_send_player(name, "âŒ Requires: " .. ability_by_id[ability.requires].name)
                    end
                end
                
                -- Check stat points
                local cost = ability.cost or 1
                if data.stat_points < cost then
                    can_unlock = false
                    minetest.chat_send_player(name, "âŒ Need " .. cost .. " stat points!")
                end
                
                if can_unlock then
                    data.unlocked[ability.id] = current_level + 1
                    data.stat_points = data.stat_points - cost
                    changed = true
                    
                    minetest.chat_send_player(name, "âœ¨ Unlocked: " .. ability.name .. " Level " .. (current_level + 1) .. "!")
                    data.tooltip = string.format("âœ¨ Unlocked %s to Level %d!", ability.name, current_level + 1)
                    
                    -- Grant achievement for first ability
                    if achievement_progress then
                        achievement_progress(player, "unlock_first_ability", 1)
                    end
                end
            end
        end
    end
    
    -- Handle scrollbar events for graph panning
    if fields.graph_scroll_x then
        local event = minetest.explode_scrollbar_event(fields.graph_scroll_x)
        if event.type == "CHG" then
            data.scroll_x = event.value
            changed = true
        end
    end
    
    if fields.graph_scroll_y then
        local event = minetest.explode_scrollbar_event(fields.graph_scroll_y)
        if event.type == "CHG" then
            data.scroll_y = event.value
            changed = true
        end
    end
    
    if changed then
        save_ability_data(player, data)
    end
    
    -- Refresh formspec (use unified inventory if that's where we are)
    if formname == "" or formname == "unified_inventory" then
        if get_unified_inventory then
            player:set_inventory_formspec(get_unified_inventory(player))
        end
    else
        minetest.show_formspec(name, "ability_tree_new", get_ability_formspec_new(player))
    end
end)

-- Chat command to open new abilities screen
minetest.register_chatcommand("abilities2", {
    description = "Open new advanced abilities screen",
    func = function(name)
        local player = minetest.get_player_by_name(name)
        if player then
            minetest.show_formspec(name, "ability_tree_new", get_ability_formspec_new(player))
            return true, "Opening abilities!"
        end
        return false, "Player not found"
    end
})

-- Apply abilities on join
minetest.register_on_joinplayer(function(player)
    minetest.after(1, function()
        if minetest.get_player_by_name(player:get_player_name()) then
            apply_stats(player)
            apply_toggles(player)
        end
    end)
end)

minetest.log("action", "[ability_system_new] Advanced ability system loaded! âš¡")
